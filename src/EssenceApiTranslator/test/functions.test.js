const functions = require("../translator/functions")

test("filterInvalidFunctions returns a valid function", () => {
    const rawFunction = "ActionMarker_StartAction( String name ) RETURNS:  =>Start the given action marker's FX."
    const actual = functions.filterInvalidFunctions([rawFunction])
    const expected = [rawFunction]

    expect(actual).toEqual(expected)
})


test("filterInvalidFunctions skips empty lines", () => {
    const rawFunction = ""
    const actual = functions.filterInvalidFunctions([rawFunction])
    const expected = []

    expect(actual).toEqual(expected)
})

test("filterInvalidFunctions skips lines starting with #", () => {
    const rawFunction = "# GENERATED BY WSCITE_API.XSL   DO NOT EDIT BY HAND!"
    const actual = functions.filterInvalidFunctions([rawFunction])
    const expected = []

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles functions with no arguments", () => {
    const rawFunction = "AI_CreateAICombatFitnessLogs(  ) RETURNS:  =>Create the combat feature logs in the game log directory"
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "AI_CreateAICombatFitnessLogs",
        arguments: [],
        comment: "Create the combat feature logs in the game log directory"
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles functions with one argument", () => {
    const rawFunction = "ActionMarker_StartAction( String name ) RETURNS:  =>Start the given action marker's FX."
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "ActionMarker_StartAction",
        arguments: [{
            type_: "String",
            name: "name"
        }],
        comment: "Start the given action marker's FX."
    }]

    expect(actual).toEqual(expected)
})


test("deserialiseRawFunctions throws error for invalid arguments", () => {
    const rawFunction = "ActionMarker_StartAction( String name foo ) RETURNS:  =>Start the given action marker's FX."
    const wrap = () => {
        functions.deserialiseRawFunctions([rawFunction])
    }
    expect(wrap).toThrow(functions.RawFunctionDeserialisationError)
})

test("deserialiseRawFunctions handles functions with two arguments", () => {
    const rawFunction = "AI_ClearPBGRepairPriority( PlayerID pPlayer, String pbgShortname ) RETURNS:  =>This clears the repair priority value for a given squad or building PBG."
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "AI_ClearPBGRepairPriority",
        arguments: [
            {type_: "PlayerID", name: "pPlayer"},
            {type_: "String", name: "pbgShortname"}
        ],
        comment: "This clears the repair priority value for a given squad or building PBG."
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles functions with vector arguments", () => {
    const rawFunction = "AIProductionScoring_MaxScoringFunction( PlayerID aiPlayer, vector< ScoringFunction*> innerScoringFunction ) RETURNS:  =>Create a MaxScoringFunction scoring function."
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "AIProductionScoring_MaxScoringFunction",
        arguments: [
            {type_: "PlayerID", name: "aiPlayer"},
            {type_: "vector<ScoringFunction*>", name: "innerScoringFunction"}
        ],
        comment: "Create a MaxScoringFunction scoring function."
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles functions with list arguments", () => {
    const rawFunction = "AIStateTree_SpawnRootControllerWithStateModelTunings(String list stateModelEntityTypeListTunings ) RETURNS:  =>On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "AIStateTree_SpawnRootControllerWithStateModelTunings",
        arguments: [
            {type_: "String[]", name: "stateModelEntityTypeListTunings"}
        ],
        comment: "On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles functions with union type arguments", () => {
    const rawFunction = "AIStateTree_SpawnRootControllerWithStateModelTunings( EGroupID / SGroup group ) RETURNS:  =>On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "AIStateTree_SpawnRootControllerWithStateModelTunings",
        arguments: [
            {type_: "EGroupID | SGroup", name: "group"}
        ],
        comment: "On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles functions with dumb comments in the arguments (value to be compared against)", () => {
    const rawFunction = "AIStateTree_SpawnRootControllerWithStateModelTunings( Integer amount (value to be compared against), Boolean repeat ) RETURNS:  =>On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "AIStateTree_SpawnRootControllerWithStateModelTunings",
        arguments: [
            {type_: "Integer", name: "amount"},
            {type_: "Boolean", name: "repeat"}
        ],
        comment: "On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles functions with dumb comments in the arguments 1 based player slot index", () => {
    const rawFunction = "AIStateTree_SpawnRootControllerWithStateModelTunings( target player, 1 based player slot index ) RETURNS:  =>On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "AIStateTree_SpawnRootControllerWithStateModelTunings",
        arguments: [
            {type_: "target", name: "player"},
            {type_: "Integer", name: "oneBasedPlayerSlotIndex"},
        ],
        comment: "On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles functions with dumb comments in the arguments  event type id", () => {
    const rawFunction = "AIStateTree_SpawnRootControllerWithStateModelTunings(  event type id ) RETURNS:  =>On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "AIStateTree_SpawnRootControllerWithStateModelTunings",
        arguments: [
            {type_: "GameEventID", name: "eventID"},
        ],
        comment: "On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles functions with dumb comments in the arguments a scar position. Won't accept a position extremely close (std::numeric_limits<float>::min()) to the existing ones.", () => {
    const rawFunction = "AIStateTree_SpawnRootControllerWithStateModelTunings( a scar position. Won't accept a position extremely close (std::numeric_limits<float>::min()) to the existing ones. ) RETURNS:  =>On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "AIStateTree_SpawnRootControllerWithStateModelTunings",
        arguments: [
            {type_: "Position", name: "position"},
        ],
        comment: "On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles UI_DestroyTagForPosition", () => {
    const rawFunction = "UI_DestroyTagForPosition( same of or extremely close (std::numeric_limits<float>::min()) to an existing position. If there are multiple candidates, delete the closest. ) RETURNS:  =>Destroy a position tag"
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "UI_DestroyTagForPosition",
        arguments: [
            {type_: "Position", name: "position"},
        ],
        comment: "Docs are cooked, check file:///C:/program%20files/steam/steamapps/common/age%20of%20empires%20iv/scardocs/html/function_list.htm#UI_DestroyTagForPosition"
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles UI_DestroyTagForPosition", () => {
    const rawFunction = "UI_DestroyTagForPosition( same of or extremely close (std::numeric_limits<float>::min()) to an existing position. If there are multiple candidates, delete the closest. ) RETURNS:  =>Destroy a position tag"
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "UI_DestroyTagForPosition",
        arguments: [
            {type_: "Position", name: "position"},
        ],
        comment: "Docs are cooked, check file:///C:/program%20files/steam/steamapps/common/age%20of%20empires%20iv/scardocs/html/function_list.htm#UI_DestroyTagForPosition"
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles UI_SetControlGroupSelectedCallback", () => {
    const rawFunction = "UI_SetControlGroupSelectedCallback( in the format of function(controlGroupIndex) ) RETURNS:  =>Sets a callback firing when user select a control group either by hotkey or by control group button"
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "UI_SetControlGroupSelectedCallback",
        arguments: [
            {type_: "function", name: "callback"},
        ],
        comment: "Sets a callback firing when user select a control group either by hotkey or by control group button in the format function(controlGroupIndex)"
    }]

    expect(actual).toEqual(expected)
})

test("deserialiseRawFunctions handles functions with '=' in them", () => {
    const rawFunction = "AIStateTree_SpawnRootControllerWithStateModelTunings( SGroupID = SGroup ) RETURNS:  =>On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    const actual = functions.deserialiseRawFunctions([rawFunction])
    const expected = [{
        name: "AIStateTree_SpawnRootControllerWithStateModelTunings",
        arguments: [
            {type_: "SGroupID", name: "SGroup"},
        ],
        comment: "On the AIPlayer statetree, spawn a Root Controller with tunings that can be pushed onto the Root Controller's StateModel."
    }]

    expect(actual).toEqual(expected)
})

test("generateLuaCats generates luaCATS for one function with no args", () => {
    const func = {
        name: "AI_CombatFitnessGetHealerPBGs",
        arguments: [],
        comment: "Returns healer feature option pbgs"
    }
    
    const actual = functions.generateLuaCats([func])
    const expected = [
        "".concat(
            "---comment Returns healer feature option pbgs\n",
            "function AI_CombatFitnessGetHealerPBGs()\n",
            "end\n"
        )
    ]

    expect(actual).toEqual(expected)
})

test("generateLuaCats generates luaCATS for one function with one arg", () => {
    const func = {
        name: "ActionMarker_StartAction",
        arguments: [{
            type_: "String",
            name: "name"
        }],
        comment: "Start the given action marker's FX."
    }

    const actual = functions.generateLuaCats([func])
    const expected = [
        "".concat(
            "---comment Start the given action marker's FX.\n",
            "---@param name String\n",
            "function ActionMarker_StartAction(name)\n",
            "end\n"
        )
    ]

    expect(actual).toEqual(expected)
})

test("generateLuaCats generates luaCATS for one function with two args", () => {
    const func = {
        name: "AI_ClearPBGRepairPriority",
        arguments: [
            {type_: "PlayerID", name: "pPlayer"},
            {type_: "String", name: "pbgShortname"}
        ],
        comment: "This clears the repair priority value for a given squad or building PBG."
    }

    const actual = functions.generateLuaCats([func])
    const expected = [
        "".concat(
            "---comment This clears the repair priority value for a given squad or building PBG.\n",
            "---@param pPlayer PlayerID\n",
            "---@param pbgShortname String\n",
            "function AI_ClearPBGRepairPriority(pPlayer, pbgShortname)\n",
            "end\n"
        )
    ]
})
